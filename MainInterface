#!/usr/bin/env python3
import argparse
import time
import struct
import can

# ---------- ODrive CAN message IDs ----------
def _id(node, code): return (node << 5) | code
ID_HEARTBEAT       = 0x01
ID_SET_AXIS_STATE  = 0x07
ID_GET_ENCODER     = 0x09
ID_SET_INPUT_POS   = 0x0C
ID_CLEAR_ERRORS    = 0x18
ID_OD_WRITE        = 0x17

AXIS_IDLE          = 1
AXIS_CLOSED_LOOP   = 8

# ---------- Bus ----------
def make_bus(channel="can0", interface="socketcan"):
    return can.interface.Bus(channel=channel, interface=interface)

# ---------- Core helpers (unchanged behavior) ----------
def send_pos(bus, node_id, pos_target, velocity_ff=0, torque_ff=0):
    data = struct.pack('<fhh', float(pos_target), int(velocity_ff), int(torque_ff))
    msg = can.Message(arbitration_id=_id(node_id, ID_SET_INPUT_POS),
                      data=data, is_extended_id=False)
    bus.send(msg)

def request_pos(bus, node_id, timeout_s=0.010):
    rid = _id(node_id, ID_GET_ENCODER)
    # RTR request
    bus.send(can.Message(arbitration_id=rid, data=b'',
                         is_extended_id=False, is_remote_frame=True))
    t0 = time.time()
    while time.time() - t0 < timeout_s:
        msg = bus.recv(timeout=timeout_s)
        if msg and msg.arbitration_id == rid and not msg.is_remote_frame and len(msg.data) >= 8:
            pos, vel = struct.unpack('<ff', msg.data[:8])
            return pos, vel
    return None, None

def enter_closed_loop(bus, node_id, wait=True, timeout_s=2.0):
    bus.send(can.Message(arbitration_id=_id(node_id, ID_SET_AXIS_STATE),
                         data=struct.pack('<I', AXIS_CLOSED_LOOP), is_extended_id=False))
    if not wait:
        return True
    hb = _id(node_id, ID_HEARTBEAT)
    t0 = time.time()
    while time.time() - t0 < timeout_s:
        msg = bus.recv(timeout=0.05)
        if msg and msg.arbitration_id == hb and len(msg.data) >= 7:
            _, axis_state, _, _ = struct.unpack('<IBBB', msg.data[:7])
            if axis_state == AXIS_CLOSED_LOOP:
                return True
    return False

def exit_closed_loop(bus, node_id):
    bus.send(can.Message(arbitration_id=_id(node_id, ID_SET_AXIS_STATE),
                         data=struct.pack('<I', AXIS_IDLE), is_extended_id=False))

def clear_errors(bus, node_id):
    bus.send(can.Message(arbitration_id=_id(node_id, ID_CLEAR_ERRORS),
                         data=b'', is_extended_id=False))

def write_float_parameter(bus, node_id, index, value, subindex=0x00):
    # SDO Write for 32-bit float = 0x2B
    data = struct.pack('<BHBBf', 0x2B, index, subindex, 0x00, float(value))
    msg = can.Message(arbitration_id=_id(node_id, ID_OD_WRITE),
                      data=data[:8], is_extended_id=False)
    bus.send(msg)

# ---------- CLI actions ----------
def cmd_status(bus, nid):
    pos, vel = request_pos(bus, nid)
    if pos is None:
        print("No encoder response.")
    else:
        print(f"Pos: {pos:.3f} turns  |  Vel: {vel:.3f} tr/s")

def cmd_up(bus, nid, step, vel_ff):
    pos, _ = request_pos(bus, nid)
    if pos is None:
        print("No encoder response.")
        return
    target = pos + step
    send_pos(bus, nid, target, vel_ff=vel_ff)
    print(f"Move UP: {pos:.3f} → {target:.3f} turns (vel_ff={vel_ff})")

def cmd_down(bus, nid, step, vel_ff):
    pos, _ = request_pos(bus, nid)
    if pos is None:
        print("No encoder response.")
        return
    target = pos - step
    send_pos(bus, nid, target, vel_ff=-vel_ff)
    print(f"Move DOWN: {pos:.3f} → {target:.3f} turns (vel_ff={-vel_ff})")

def cmd_goto(bus, nid, pos, vel_ff):
    send_pos(bus, nid, pos, vel_ff=vel_ff)
    print(f"GOTO: {pos:.3f} turns (vel_ff={vel_ff})")

# ---------- Main ----------
def main():
    p = argparse.ArgumentParser(description="ODrive CAN command-line controller")
    p.add_argument("--channel", default="can0", help="socketcan channel (default: can0)")
    p.add_argument("--interface", default="socketcan", help="python-can interface (default: socketcan)")
    p.add_argument("--node", type=int, default=1, help="ODrive node id (default: 1)")
    sub = p.add_subparsers(dest="cmd", required=True)

    sub.add_parser("enable", help="enter closed loop")
    sub.add_parser("disable", help="exit to IDLE")
    sub.add_parser("clear", help="clear errors")
    sub.add_parser("status", help="read position/velocity")

    up = sub.add_parser("up", help="increment position by +step turns")
    up.add_argument("--step", type=float, default=1.0)
    up.add_argument("--vel-ff", type=int, default=0)

    down = sub.add_parser("down", help="decrement position by -step turns")
    down.add_argument("--step", type=float, default=1.0)
    down.add_argument("--vel-ff", type=int, default=0)

    goto = sub.add_parser("goto", help="move to absolute position (turns)")
    goto.add_argument("pos", type=float)
    goto.add_argument("--vel-ff", type=int, default=0)

    args = p.parse_args()
    bus = make_bus(args.channel, args.interface)
    nid = args.node

    if args.cmd == "enable":
        ok = enter_closed_loop(bus, nid, wait=True)
        print("Closed loop" if ok else "Failed to enter closed loop")
    elif args.cmd == "disable":
        exit_closed_loop(bus, nid)
        print("Set axis to IDLE")
    elif args.cmd == "clear":
        clear_errors(bus, nid)
        print("Errors cleared")
    elif args.cmd == "status":
        cmd_status(bus, nid)
    elif args.cmd == "up":
        cmd_up(bus, nid, args.step, args.vel_ff)
    elif args.cmd == "down":
        cmd_down(bus, nid, args.step, args.vel_ff)
    elif args.cmd == "goto":
        cmd_goto(bus, nid, args.pos, args.vel_ff)

if __name__ == "__main__":
    main()
