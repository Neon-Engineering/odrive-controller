import sys							
import time								
import math								
import struct
from typing import Optional		
from PyQt5 import QtWidgets, QtCore					
import can								
from collections import deque

#import module components
from RaspberryPi.GUI.setupGUI import ControlPanel
from RaspberryPi.modules.SingleAxisController import Controls
from RaspberryPi.modules.SingleAxisController import send_position, request_position, enter_closed_loop, exit_closed_loop
from RaspberryPi.modules.SensorReadout import Logger

class App(QtWidgets.QMainWindow):			
    def __init__(self):					
        super().__init__()				
        self.setWindowTitle("Raspberry Pi Control Interface")	
        self.setGeometry(100, 100, 800, 600)	

        # Initialize CAN bus
        self.bus = can.interface.Bus(channel='can0', bustype='socketcan')

        # Initialize components
        self.control_panel = ControlPanel(self)
        self.setCentralWidget(self.control_panel)

        self.axis_controller = Controls(self.bus)
        self.sensor_logger = Logger(self.bus)

        # Setup timers for periodic updates
        self.update_timer = QtCore.QTimer()
        self.update_timer.timeout.connect(self.update_status)
        self.update_timer.start(100)  # Update every 100 ms

    def update_status(self):
        # Update control panel with current status
        status = self.axis_controller.get_status()
        self.control_panel.update_status_display(status)

        # Log sensor data
        sensor_data = self.sensor_logger.read_sensors()
        self.sensor_logger.log_data(sensor_data)

    def closeEvent(self, event):
        # Clean up resources on close
        self.axis_controller.shutdown()
        self.sensor_logger.close()
        event.accept()

    def run(self):
        self.show()						
        sys.exit(App.exec_())
        control_panel.addWidget(btn)
        self.motor_buttons.append(btn)
        self.update_button_color(btn.isChecked(), i)
    
    def update_button_color(self, checked, index):
        btn = self.motor_buttons[index]
        if checked:
            btn.setStyleSheet("background-color: green; color: white; font-size: 18px;")
        else:
            btn.setStyleSheet("background-color: red; color: white; font-size: 18px;")
# Function to start the homing sequence
    def start_homing_sequence(self):
        self.status_box.setText("Homing motors...")
        self.homing_thread = HomingThread(self.motor_nodes)
        self.homing_thread.homing_done.connect(self.finish_homing_sequence)
        self.homing_thread.start()

    # Function to save home offsets and enable command/plotting timers
    def finish_homing_sequence(self, offsets):
        self.home_offsets = offsets                         # Save home offsets in control panel class
        self.status_box.setText("Manual control active.")   # Status box
        self.setEnabled(True)                               # Enable GUI after homing finishes
        self.cmd_timer.start(50)                            # Start timer to update commanded motor positions
        self.plot_timer.start(50)                           # Start timer to update plot

    # Function to calculate motor position targets and send commands
    def update_command(self):
        if self.send_button.isChecked():
            motor_states = [int(btn.isChecked()) for btn in self.motor_buttons]
            motor_active = sum(motor_states)

            if self.behavior_buttons[0].isChecked():
                act_length_target = self.slider.value() / 100.0 - 2.0		# Fix this with the other slider values that are way too big
                self.last_cmd = act_length_target
            elif self.behavior_buttons[1].isChecked():
                if not self.sine_sweep_active:
                    self.sine_start_time = time.time()
                    self.sine_sweep_active = True
                t = time.time() - self.sine_start_time
                freq = self.slider.value() / 150.0
                amp = 2.0													# Amplitude of sine wave
                act_length_target = amp * math.sin(2 * math.pi * freq * t)
                self.last_cmd = act_length_target
            else:
                act_length_target = 0.0

            if motor_active > 0:
                act_contribute = act_length_target / motor_active										# Equal stroke contributions
                self.rev_targets = [
                    self.home_offsets[0] - motor_states[0] * act_contribute / Pitch_12,					# Motor 1 target position
                    self.home_offsets[1] - motor_states[1] * act_contribute / (Pitch_12 + Pitch_23),	# Motor 2 target position
                    self.home_offsets[2] + motor_states[2] * act_contribute / Pitch_23,	]				# Motor 3 target position
                for i in range(3):
                    send_position(self.rev_targets[i], self.motor_nodes[i])
        else:
            self.sine_sweep_active = False

        for i, node_id in enumerate(self.motor_nodes):
            pos = request_position(node_id)
            if pos is not None:
                self.last_fb[i] = pos
                
    # Function to update the live plot
    def update_plot(self):
        t = time.time() - self.start_time
        self.time_vals.append(t)
        self.cmd_vals.append(self.last_cmd)

        rel_fb = [
            self.last_fb[0] - self.home_offsets[0],
        ]
        
        actual_length = (
            rel_fb[0]
        ) * (-1)
        self.fb_vals[0].append(actual_length)

        # HEALTH CHECK: Check travel limits
        if abs(actual_length) > self.travel_lim:
            for node in [0, 1, 2]:	
                exit_closed_loop(node)
            self.status_box.setText("ABORT: Travel limit exceeded")
            print(f"ABORT: Travel limit exceeded")

        # DATA ACQUISITION
        if self.record_button.isChecked():	# Store data only when record button is pressed
            self.data_log.append([t, self.rev_targets[0], rel_fb[0], self.rev_targets[1], rel_fb[1], self.rev_targets[2], rel_fb[2], actual_length ])		# Append time and motor positions in array

        # Update plot
        self.cmd_curve.setData(self.time_vals, self.cmd_vals)
        self.fb_curve.setData(self.time_vals, self.fb_vals[0])
        self.plot.setXRange(max(0, t - self.history_sec), t)

    # Function to handle styling of activate button
    def handle_send_toggled(self, checked):
        if not checked:
            self.send_button.setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
            self.sine_sweep_active = False
        else:
            self.send_button.setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")

    # Function to handle RECORD button and CSV creation
    def handle_record_toggled(self, checked):
        if not checked:
            self.record_button.setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
            # Create CSV to store data
            time_stamp = time.strftime("%Y%m%d-%H%M%S")	# Format time stamp: year|month|day-hour|minute|second
            file_name = f"TestData_{time_stamp}.csv"	# Create full CSV file name
            with open(file_name, mode='w', newline='') as file:
                writer = csv.writer(file)
                writer.writerow(['Time','M1 Target','M1 Pos','M2 Target','M2 Pos','M3 Target','M3 Pos','Act Length'])
                writer.writerows(self.data_log)
            self.data_log = []	# Reset array
        else:
            self.record_button.setStyleSheet("""QPushButton { background-color: green; color: white; font-weight: bold; border-radius: 5px; padding: 10px; }""")
            
    # Function to send motors home
    def handle_home(self):
        self.send_button.setChecked(False)
        self.sine_sweep_active = False
        self.last_cmd = 0.0
        self.rev_targets = [0.0, 0.0, 0.0]
        for i in range(3):
            send_position(self.home_offsets[i], self.motor_nodes[i])
    
    def handle_reset(self):
        self.send_button.setChecked(False)
        self.sine_sweep_active = False
        self.last_cmd = 0.0
        self.rev_targets = [0.0]  # Update for plot
        for i in range(3):
            exit_closed_loop(i)
            enter_closed_loop(i)
        for i in range(3):
            send_position(self.home_offsets[i], self.motor_nodes[i])

    # Function to update label above slider
    def update_slider_label(self):
        if self.behavior_buttons[0].isChecked():
            value = self.slider.value() / 100.0 - 2.0
            self.slider_label.setText(f"Position: {value:.2f}")
        elif self.behavior_buttons[1].isChecked():
            value = self.slider.value() / 150.0
            self.slider_label.setText(f"Frequency: {value:.2f} Hz")
    
    # Function to handle what happens when you switch behaviors
    def handle_behavior_toggle(self):
        self.send_button.setChecked(False)
        if self.behavior_buttons[0].isChecked():
            self.slider.setMinimum(0)
            self.slider.setMaximum(400)
            self.slider.setValue(200)
            self.slider_label.setText("Position: 0.00")
            self.behavior_buttons[0].setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
            self.behavior_buttons[1].setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        elif self.behavior_buttons[1].isChecked():
            self.slider.setMinimum(0)
            self.slider.setMaximum(300)
            self.slider.setValue(100)
            self.slider_label.setText("Frequency: 1.00 Hz")
            self.behavior_buttons[0].setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
            self.behavior_buttons[1].setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")  
        
    # Function to update the color of (some) latching pushbuttons
    def update_button_color(self):
        # Motor 1 formatting
        if self.motor_buttons[0].isChecked():
            self.motor_buttons[0].setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        else:
            self.motor_buttons[0].setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        # Motor 2 formatting
        if self.motor_buttons[1].isChecked():
            self.motor_buttons[1].setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        else:
            self.motor_buttons[1].setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        # Motor 3 formatting
        if self.motor_buttons[2].isChecked():
            self.motor_buttons[2].setStyleSheet("""QPushButton {background-color: green; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        else:
            self.motor_buttons[2].setStyleSheet("""QPushButton {background-color: darkred; color: white; font-weight: bold; font-size: 20px; border-radius: 5px; padding: 10px; }""")
        pass
        
    # Function to perform shut down and exit application
    def exit_application(self):
        if self.homing_thread and self.homing_thread.isRunning():
            self.homing_thread.interrupted = True
            self.homing_thread.wait()
            
        print(f"Shutting down")
        
        print(f"Disabling closed loop control")
        for node in [0]:
            exit_closed_loop(node)	# Exit closed loop control
        QtWidgets.QApplication.quit()
    
    # Function to exit if esc key is pressed
    def keyPressEvent(self, event):
        if event.key() == QtCore.Qt.Key_Escape:
            self.exit_application()